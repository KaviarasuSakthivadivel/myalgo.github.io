You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a **double booking**.

A **double booking** happens when two events have some non-empty intersection (i.e., some moment is common to both events.).

The event can be represented as a pair of integers `start` and `end` that represents a booking on the half-open interval `[start, end)`, the range of real numbers `x` such that `start <= x < end`.

Implement the `MyCalendar` class:

- `MyCalendar()` Initializes the calendar object.
- `boolean book(int start, int end)` Returns `true` if the event can be added to the calendar successfully without causing a **double booking**. Otherwise, return `false` and do not add the event to the calendar.

**Example 1:**

**Input**
["MyCalendar", "book", "book", "book"]
[[], [10, 20], [15, 25], [20, 30]]
**Output**
[null, true, false, true]

**Explanation**
MyCalendar myCalendar = new MyCalendar();
myCalendar.book(10, 20); // return True
myCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event.
myCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.

**Constraints:**

- `0 <= start < end <= 109`
- At most `1000` calls will be made to `book`.

#### Overview

The primary challenge in this problem is to find a proper data structure and an efficient algorithm to maintain all valid events, including **querying** potential conflicting existing events and **inserting** new valid events.

In this solution article, we first start with a straightforward idea of brute force to warm up, then one step forward, we improve the naive approach to keep all existing events in sorted order and reduce the time complexity.

#### Approach #1: Brute Force

**Intuition**

When booking a new event `[start, end)`, check if every current event conflicts with the new event. If none of them do, we can book the event.

**Algorithm**

We will maintain a list of interval _events_ (not necessarily sorted). Evidently, two events `[s1, e1)` and `[s2, e2)` do _not_ conflict if and only if one of them starts after the other one ends: either `e1 <= s2` OR `e2 <= s1`. By De Morgan's laws, this means the events conflict when `s1 < e2` AND `s2 < e1`.

**Implementation**

```java
class MyCalendar {

    List<int[]> bookings;
    
    public MyCalendar() {
        bookings = new ArrayList<>();
    }
    
    public boolean book(int start, int end) {
        
        // Two events (s1, e1) and (s2, e2) are said to conflict when s1 < e2 and s2 < e1
        for(int[] b : bookings) {
            if(b[0] < end && start < b[1]) {
                return false;
            }
        }
        
        bookings.add(new int[]{start, end});
        
        return true;
    }
}
```

# Another method using TreeMap

**Solution 2: Keep existing books sorted and only check 2 books start right before & after the new book starts**  
Another way to check overlap of 2 intervals is `a started with b`, or, `b started within a`.

Keep the intervals sorted,  
if the interval started right before the new interval contains the start, or  
if the interval started right after the new interval started within the `new interval`.

```python
   floor      ceiling
... |----| ... |----| ...
       |---------|
      s         e
if s < floor.end or e > ceiling.start, there is an overlap.

Another way to think of it:
If there is an interval start within the new book (must be the ceilingEntry) at all, or
books: |----|   |--|
            s |------| e

books: |----|   |----|
            s |----| e
If the new book start within an interval (must be the floorEntry) at all
books: |-------|   |--|
       s |---| e

books: |----|   |----|
        s |----| e
There is a overlap 
```

**Java**  
TreeSet

```java
class MyCalendar {
    TreeSet<int[]> books = new TreeSet<int[]>((int[] a, int[] b) -> a[0] - b[0]);

    public boolean book(int s, int e) {
        int[] book = new int[] { s, e }, floor = books.floor(book), ceiling = books.ceiling(book);
        if (floor != null && s < floor[1]) return false; // (s, e) start within floor
        if (ceiling != null && ceiling[0] < e) return false; // ceiling start within (s, e)
        books.add(book);
        return true;
    }
}
```

TreeMap

```java
class MyCalendar {
    TreeMap<Integer, Integer> books = new TreeMap<>();

    public boolean book(int s, int e) {
        java.util.Map.Entry<Integer, Integer> floor = books.floorEntry(s), ceiling = books.ceilingEntry(s);
        if (floor != null && s < floor.getValue()) return false; // (s, e) start within floor
        if (ceiling != null && ceiling.getKey() < e) return false; // ceiling start within (s, e)
        books.put(s, e);
        return true;
    }
}
```
