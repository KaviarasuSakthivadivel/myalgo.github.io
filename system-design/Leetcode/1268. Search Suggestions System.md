You are given an array of strings `products` and a string `searchWord`.

Design a system that suggests at most three product names from `products` after each character of `searchWord` is typed. Suggested products should have common prefix with `searchWord`. If there are more than three products with a common prefix return the three lexicographically minimums products.

Return _a list of lists of the suggested products after each character of_ `searchWord` _is typed_.

**Example 1:**

**Input:** products = ["mobile","mouse","moneypot","monitor","mousepad"], searchWord = "mouse"
**Output:** [["mobile","moneypot","monitor"],["mobile","moneypot","monitor"],["mouse","mousepad"],["mouse","mousepad"],["mouse","mousepad"]]
**Explanation:** products sorted lexicographically = ["mobile","moneypot","monitor","mouse","mousepad"].
After typing m and mo all products match and we show user ["mobile","moneypot","monitor"].
After typing mou, mous and mouse the system suggests ["mouse","mousepad"].

**Example 2:**

**Input:** products = ["havana"], searchWord = "havana"
**Output:** [["havana"],["havana"],["havana"],["havana"],["havana"],["havana"]]
**Explanation:** The only word "havana" will be always suggested while typing the search word.

## Solution

```java
class Solution {
    public List<List<String>> suggestedProducts(String[] products, String searchWord) {
        List<List<String>> result = new ArrayList<>();
        Trie trie = new Trie();

        for(String product : products) {
            trie.insert(product);
        }

        for(int i = 1; i <= searchWord.length(); i++) {
            String prefix = searchWord.substring(0, i);
            result.add(trie.getWordsStartingWith(prefix));
        }

        return result;
    }

    static class Trie {
        private TrieNode root;

        public Trie() {
            root = new TrieNode();
        }

        public void insert(String word) {
            TrieNode current = root;
            for (char ch : word.toCharArray()) {
                if (current.children.get(ch) == null) {
                    current.children.put(ch, new TrieNode());
                }
                current = current.children.get(ch);
            }
            current.isWord = true;
        }

        public List<String> getWordsStartingWith(String prefix) {
            List<String> wordList = new ArrayList<>();

            TrieNode current = root;
            for(char ch : prefix.toCharArray()) {
                if(current.children.get(ch) == null) {
                    return wordList;
                }
                current = current.children.get(ch);
            }
            runDFS(current, prefix, wordList);

            return wordList;
        }

        private void runDFS(TrieNode current, String prefix, List<String> wordList) {
            if(wordList.size() == 3) {
                return;
            }

            if(current.isWord) {
                wordList.add(prefix);
            }

            for(int i = 0; i < 26; i++) {
                char ch = (char)(i + 'a');
                if(current.children.containsKey(ch)) {
                    runDFS(current.children.get(ch), prefix + ch, wordList);
                }
            }
        }
    }

    static class TrieNode {
        HashMap<Character, TrieNode> children;
        boolean isWord;

        public TrieNode() {
            children = new HashMap<>();
        }
    }
}
```