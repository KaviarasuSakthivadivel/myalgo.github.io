Given an `n x n` array of integers `matrix`, return _the **minimum sum** of any **falling path** through_ `matrix`.

A **falling path** starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position `(row, col)` will be `(row + 1, col - 1)`, `(row + 1, col)`, or `(row + 1, col + 1)`.

![[failing1-grid_931.jpeg]]


**Input:** matrix = [[2,1,3],[6,5,4],[7,8,9]]
**Output:** 13
**Explanation:** There are two falling paths with a minimum sum as shown.

## Solution 

## Solution

---

#### Overview

Given a 2D `matrix(row, col)`, we have to find the sum of the minimum falling path in a matrix.  
To begin with, let's try to understand, what is a falling path?  
To put it in simple words, it is a path that satisfies the following criteria,

1. A falling path is a path that begins at **any** cell in the first row of the matrix and ends at **any** cell in the last row of the matrix.
2. From a certain cell `(row, col)` in the falling path, we can only move to 3 possible cells, `(row + 1, col)` , `(row + 1, col + 1)`, `(row + 1, col - 1)`.

![[931_overview.png]]

As the name suggests, the falling path sum is the sum of values of all the cells in the chosen path. Our goal is to find the minimum sum from all possible paths. Let's consider different approaches that can be used to solve this problem. We will begin with the brute force approach and optimize it using dynamic programming.

  

---

#### Approach 1: Brute Force Using Depth First Search

**Intuition**

Brute Force is generally the straightforward approach to solving the problem. You can think of the brute force approach as

"Given pen and paper in your hand, how will you try to solve the problem"?

Though the brute force approach is considered to be the most exhaustive and unoptimized approach, implementing this approach first gives a deeper understanding of the basis of the problem, which can further help to shape a better-optimized solution.

Let's understand the brute force approach with the following example,

![[931_example_problem.png]]

> Before reading the following section, try to find the minimum falling path for the above matrix on your own.

In this example, if we start at cell `(0, 1)`, the next cell in the path could be `(1, 0)`, `(1, 1)`, or `(1, 2)`. From the current position, we cannot determine which path will give us the minimum path sum, so let's try all the possible paths.

![[931_example_3possibilities.png]]


The minimum path sum from cell `(0, 1)` is "5" - going from `(0, 1)` to `(1, 2)`. Does that mean that we can greedily choose this path and move ahead, discarding the other paths?  
Let's find the minimum falling path if we choose the path with the sum "5" i.e `(0, 1)` to `(1, 2)`.

![[931_Explore_greedy_path.png]]

Thus, the minimum falling path sum is "14". Now, let's explore other paths starting from cell `(0, 1)`.

![[931_Explore_All_Paths.png]]

The minimum falling path sum is now "13" i.e `(0, 1)` -> `(1, 1)` -> `(2, 0)`.

This proves that the greedy approach will not work for this problem. A sub-path with the lowest subset-sum cannot guarantee the lowest sum for the entire path. We must explore all possible paths to find the one with the smallest sum.

Since we have to try all paths from any cell, the solution must generate all the possible falling paths and track the one with a minimum sum. To try all possible combinations, we can perform a depth-first search on the matrix.

> The Depth First Search is an exhaustive search process wherein we will traverse all the cells in a path. On reaching the end of the path, we must undo our last step in the current path and try a different possible next step to extend the path.


```java
class Solution {
    public int minFallingPathSum(int[][] matrix) {
        int minFallingSum = Integer.MAX_VALUE;
        int n = matrix.length;
        Integer[][] memo = new Integer[n][n];

        for(int col = 0; col < n; col++) {
            minFallingSum = Math.min(minFallingSum, minFallingPathSum(matrix, 0, col, memo));
        }

        return minFallingSum;
    }

    private int minFallingPathSum(int[][] matrix, int row, int col, Integer[][] memo) {
        int n = matrix.length;
        if(col < 0 || col == n) {
            return Integer.MAX_VALUE;
        }

        if(row == n - 1) {
            return matrix[row][col];
        }

        if(memo[row][col] != null) {
            return memo[row][col];
        }

        int left = minFallingPathSum(matrix, row + 1, col - 1, memo);
        int middle = minFallingPathSum(matrix, row + 1, col, memo);
        int right = minFallingPathSum(matrix, row + 1, col + 1, memo);

        return memo[row][col] = Math.min(left, Math.min(middle, right)) + matrix[row][col];
    }
}
```