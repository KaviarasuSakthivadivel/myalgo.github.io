Given an `m x n` grid of characters `board` and a string `word`, return `true` _if_ `word` _exists in the grid_.

The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.

![[word2.jpeg]]

**Input:** board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
**Output:** true

![[word3.jpeg]]

**Input:** board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
**Output:** false

### Solution

#### Approach 1: Backtracking

**Intuition**

This problem is yet another 2D grid traversal problem, which is similar with another problem called [489. Robot Room Cleaner](https://leetcode.com/articles/robot-room-cleaner/).

Many people in the [discussion forum](https://leetcode.com/problems/word-search/discuss/) claimed that the solution is of _**DFS**_ (Depth-First Search). Although it is true that we would explore the 2D grid with the DFS strategy for this problem, it does not capture the entire nature of the solution.

> We argue that a more accurate term to summarize the solution would be _**backtracking**_, which is a methodology where we mark the current path of exploration, if the path does not lead to a solution, we then revert the change (_i.e._ backtracking) and try another path.

As the general idea for the solution, we would walk around the 2D grid, and at each step, we _mark_ our choice before jumping into the next step. And at the end of each step, we would also revert our mark so that we will have a _clean slate_ to try another _direction_. In addition, the exploration is done via the _DFS_ strategy, where we go as far as possible before we try the next direction.


![[79_example.png]]


**Algorithm**

There is a certain code pattern for all the algorithms of backtracking. For example, one can find one template in our [Explore card of Recursion II](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2793/).

The skeleton of the algorithm is a loop that iterates through each cell in the grid. For each cell, we invoke the _backtracking_ function (_i.e._ `backtrack()`) to check if we would obtain a solution, starting from this very cell.

For the backtracking function `backtrack(row, col, suffix)`, as a DFS algorithm, it is often implemented as a _recursive_ function. The function can be broke down into the following four steps:

- Step 1). At the beginning, first we check if we reach the bottom case of the recursion, where the word to be matched is empty, _i.e._ we have already found the match for each prefix of the word.
    
- Step 2). We then check if the current state is invalid, either the position of the cell is out of the boundary of the board or the letter in the current cell does not match with the first letter of the word.
    
- Step 3). If the current step is valid, we then start the exploration of backtracking with the strategy of DFS. First, we mark the current cell as _visited_, _e.g._ any non-alphabetic letter will do. Then we iterate through the four possible directions, namely _up_, _right_, _down_ and _left_. The order of the directions can be altered, to one's preference.
    
- Step 4). At the end of the exploration, we revert the cell back to its original state. Finally we return the result of the exploration.
    


```java
class Solution {

    public boolean exist(char[][] board, String word) {
        for(int i = 0; i < board.length; i++)
            for(int j = 0; j < board[0].length; j++){
                if(exist(board, i, j, word, 0))
                    return true;
            }
        return false;
    }

    private boolean exist(char[][] board, int i, int j, String word, int ind) {
        if(ind == word.length()) return true;
        if(i >= board.length || i < 0 || j < 0 || j >= board[0].length || board[i][j] != word.charAt(ind)) {
             return false;
        }
            
        board[i][j]='*'; 
        boolean result = exist(board, i-1, j, word, ind+1) ||
                            exist(board, i, j-1, word, ind+1) ||
                            exist(board, i, j+1, word, ind+1) ||
                            exist(board, i+1, j, word, ind+1);
        board[i][j] = word.charAt(ind);
        return result;
    }
}
```

