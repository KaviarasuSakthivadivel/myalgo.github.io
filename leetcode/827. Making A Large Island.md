You are given an `n x n` binary matrix `grid`. You are allowed to change **at most one** `0` to be `1`.

Return _the size of the largest **island** in_ `grid` _after applying this operation_.

An **island** is a 4-directionally connected group of `1`s.

**Example 1:**

**Input:** grid = [[1,0],[0,1]]
**Output:** 3
**Explanation:** Change one 0 to 1 and connect two 1s, then we get an island with area = 3.

**Example 2:**

**Input:** grid = [[1,1],[1,0]]
**Output:** 4
**Explanation:** Change the 0 to 1 and make the island bigger, only one island with area = 4.

**Example 3:**

**Input:** grid = [[1,1],[1,1]]
**Output:** 4
**Explanation:** Can't change any 0 to 1, only one island with area = 4.

https://takeuforward.org/data-structure/making-a-large-island-dsu-g-52/

https://www.youtube.com/watch?v=lgiz0Oup6gM&ab_channel=takeUforward

#### Approach 1: Naive Depth First Search

**Intuition**

For each `0` in the grid, let's temporarily change it to a `1`, then count the size of the group from that square.

**Algorithm**

For each `0`, change it to a `1`, then do a depth first search to find the size of that component. The answer is the maximum size component found.

Of course, if there is no `0` in the grid, then the answer is the size of the whole grid.

```java
class Solution {
    int[] dr = new int[]{-1, 0, 1, 0};
    int[] dc = new int[]{0, -1, 0, 1};

    public int largestIsland(int[][] grid) {
        int N = grid.length;

        int ans = 0;
        boolean hasZero = false;
        for (int r = 0; r < N; ++r)
            for (int c = 0; c < N; ++c)
                if (grid[r][c] == 0) {
                    hasZero = true;
                    grid[r][c] = 1;
                    ans = Math.max(ans, check(grid, r, c));
                    grid[r][c] = 0;
                }

        return hasZero ? ans : N*N;
    }

    public int check(int[][] grid, int r0, int c0) {
        int N = grid.length;
        Stack<Integer> stack = new Stack();
        Set<Integer> seen = new HashSet();
        stack.push(r0 * N + c0);
        seen.add(r0 * N + c0);

        while (!stack.isEmpty()) {
            int code = stack.pop();
            int r = code / N, c = code % N;
            for (int k = 0; k < 4; ++k) {
                int nr = r + dr[k], nc = c + dc[k];
                if (!seen.contains(nr * N + nc) && 0 <= nr && nr < N &&
                        0 <= nc && nc < N && grid[nr][nc] == 1) {
                    stack.push(nr * N + nc);
                    seen.add(nr * N + nc);
                }
            }
        }

        return seen.size();
    }
}

```

#### Approach #2: Component Sizes

**Intuition**

As in the previous solution, we check every `0`. However, we also store the size of each group, so that we do not have to use depth-first search to repeatedly calculate the same size.

However, this idea fails when the `0` touches the same group. For example, consider `grid = [[0,1],[1,1]]`. The answer is `4`, not `1 + 3 + 3`, since the right neighbor and the bottom neighbor of the `0` belong to the same group.

We can remedy this problem by keeping track of a group id (or index), that is unique for each group. Then, we'll only add areas of neighboring groups with different ids.

**Algorithm**

For each group, fill it with value `index` and remember it's size as `area[index] = dfs(...)`.

Then for each `0`, look at the neighboring group ids `seen` and add the area of those groups, plus 1 for the `0` we are toggling. This gives us a candidate answer, and we take the maximum.

To solve the issue of having potentially no `0`, we take the maximum of the previously calculated areas.

## My idea

```java
class Solution {
    private int[] DIRECTIONS = new int[] {0, 1, 0, -1, 0};

    public int largestIsland(int[][] grid) {
        int n = grid.length, index = 2;

        int[] area = new int[n * n + 2];
        int ans = 0;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] == 1) {
                    area[index] = area(grid, i, j, index);
                    ans = Math.max(ans, area[index]);
                    index++;
                }
            }
        }

        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                HashSet<Integer> seen = new HashSet<>();
                if(grid[i][j] == 0) {
                    for(int cell : getNeighbours(grid, i, j)) {
                        int r = cell / n, c = cell % n;
                        if(grid[r][c] > 1) {
                            seen.add(grid[r][c]);
                        }
                    }

                    int longest = 1;
                    for(int m : seen) {
                        longest += area[m];
                    }

                    ans = Math.max(ans, longest);
                }
            }
        }
        
        return ans;
    }

    private int area(int[][] grid, int row, int col, int index) {
        int area = 1, n = grid.length;
        if(row >= n || row < 0 || col >= n || col < 0) {
            return 0;
        }
        grid[row][col] = index;
        
        for(int cell : getNeighbours(grid, row, col)) {
            int r = cell / n, c = cell % n;
            if(grid[r][c] == 1) {
                area += area(grid, r, c, index);
            }
        }
        return area;
    }

    private List<Integer> getNeighbours(int[][] grid, int row, int col) {
        List<Integer> neighbours = new ArrayList<>();
        int n = grid.length;

        for(int i = 0; i < 4; i++) {
            int r = row + DIRECTIONS[i];
            int c = col + DIRECTIONS[i + 1];

            if(r >= n || r < 0 || c >= n || c < 0) {
                continue;
            }
            neighbours.add(r * n + c);
        }

        return neighbours;
    }
}
```